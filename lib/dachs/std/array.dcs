import std.string

class array
  - buf
  - capacity : uint
  - size : uint

    # TODO:
    # init(rhs : static_array)
    #     @size := rhs.size
    #     @capacity := @size
    #     @buf := new pointer(typeof(rhs[0])){@size}
    # end

    init(@buf : pointer, @size : uint)
        @capacity := @size
    end

    init(@size : uint, elem)
        @capacity := @size
        @buf := new pointer(typeof(elem)){@size}
        var i := 0u
        for i < @size
            @buf[i] = elem
            i += 1u
        end
    end

    copy
        var new_buf := new typeof(@buf){@size}
        var i := 0u
        for i < @size
            new_buf[i] = @buf[i]
            i += 1u
        end
        ret new [typeof(@buf[0])]{new_buf, @size}
    end

    init(s : int, block)
        @size := s as uint
        @capacity := @size
        @buf := new pointer(typeof(block(0))){@size}
        var i := 0u
        for i < @size
            @buf[i] = block(i)
            i += 1u
        end
    end

    func []=(idx, rhs)
        @buf[idx] = rhs
    end

    func clear
        @size = 0u
    end

    func size
        ret @size
    end

    func capacity
        ret @capacity
    end

    func data
        ret @buf
    end

    func out_of_bounds?(idx)
        i := idx as int
        ret i < 0 || @size <= i
    end

    func fill(elem)
        var i := 0u
        for i < @size
            @buf[i] = elem
            i += 1u
        end
    end

    func each(predicate)
        var i := 0u
        for i < @size
            predicate(@buf[i])
            i += 1u
        end
    end

    func each_with_index(predicate)
        var i := 0u
        for i < @size
            predicate(@buf[i], i)
            i += 1u
        end
    end

    func each_with_object(obj, predicate)
        self.each do |i|
            predicate(obj, i)
        end
        ret obj
    end

    func at(idx)
        if idx as uint >= @size
            ret @buf[0], true
        end

        ret @buf[idx], false
    end

    func [](idx)
        ret @buf[idx]
    end

    func empty?
        ret @size == 0u
    end

    func include?(elem)
        var i := 0u
        for i < @size
            if @buf[i] == elem
                ret true
            end
            i += 1u
        end

        ret false
    end

    func head
        ret @buf[0u]
    end

    func last
        ret @buf[@size - 1u]
    end

    func print
        print('[')

        if @empty?()
            print(']')
            ret
        end

        var i := 0u
        for i < @size - 1u
            print(@buf[i])
            print(',')
            i += 1u
        end
        print(@last())
        print(']')
    end

    func println
        @print()
        print('\n')
    end

    func ==(rhs : array)
        ret false unless @size == rhs.size

        var i := 0u
        for i < @size
            ret false unless @buf[i] == rhs[i]
            i += 1u
        end

        ret true
    end

    func !=(rhs : array)
        ret !(self == rhs)
    end

    func +(rhs : array)
        new_size := @size + rhs.size
        var new_buf := new pointer(typeof(@buf[0])){new_size}

        var i := 0u
        for i < @size
            new_buf[i] = @buf[i]
            i += 1u
        end

        i = 0u
        for i < rhs.size
            new_buf[i + @size] = rhs[i]
            i += 1u
        end

        ret new typeof(self){new_buf, new_size}
    end

  - func new_capacity(delta)
        new_size := @size + delta

        ret @capacity if new_size <= @capacity

        if @capacity == 0u
            ret new_size * 2u
        end

        var c := @capacity
        for c < new_size
            c *= 2u
        end

        ret c
    end

  - func expand_buf(new_capa)
        @buf = __builtin_realloc(@buf, new_capa)
        @capacity = new_capa
    end

    func <<(rhs : array)
        c := @new_capacity(rhs.size)

        if c > @capacity
            @expand_buf(c)
        end

        var i := 0u
        for i < rhs.size
            @buf[i + @size] = rhs[i]
            i += 1u
        end

        @size += rhs.size

        ret self
    end

    func <<(elem)
        c := @new_capacity(1u)
        if c > @capacity
            @expand_buf(c)
        end

        @buf[@size] = elem
        @size += 1u

        ret self
    end

    func map(predicate)
        var ptr := new pointer(typeof(predicate(@buf[0]))){@size}

        self.each_with_index do |e, i|
            ptr[i] = predicate(e)
        end

        ret new [typeof(ptr[0])]{ptr, @size}
    end

    func map'(predicate)
        var i := 0u
        for i < @size
            @buf[i] = predicate(@buf[i])
            i += 1u
        end
        ret self
    end

    func filter(predicate)
        var result := [] : typeof(self)

        self.each do |e|
            if predicate(e)
                println(e)
                result << e
            end
        end

        ret result
    end

    func zip_with(rhs : array, predicate)
        s := if @size < (rhs.size) then @size else rhs.size

        var ptr := new pointer(typeof(predicate(@buf[0], rhs[0]))){s}

        var i := 0u
        for i < s
            ptr[i] = predicate(@buf[i], rhs[i])
            println(@buf[i])
            i += 1u
        end

        ret new [typeof(ptr[0])]{ptr, s}
    end

    func zip(rhs : array)
        ret @zip_with(rhs) {|l, r| (l, r)}
    end

    func foldl(var init, predicate)
        var i := 0u
        for i < @size
            init = predicate(init, @buf[i])
            i += 1u
        end
        ret init
    end

    func foldl(predicate)
        fatal() if @empty?()
        ret @foldl(@buf[0], predicate)
    end

    func delete_at(var pos : uint)
        var saved := @buf[pos]
        for pos + 1u < @size
            @buf[pos] = @buf[pos + 1u]
            pos += 1u
        end
        @size -= 1u

        ret saved
    end

    func join(sep : string)
        s := self.foldl(1u){|acc, s| acc + s.size } +
            (unless @empty?() then sep.size * (@size - 1u) else 0u)

        var ptr := new pointer(char){s}
        var pos := 0u

        var i := 0u
        for i < @size
            var j := 0u
            for j < @buf[i].size
                ptr[pos] = @buf[i][j]
                j, pos += 1u, 1u
            end

            i += 1u

            unless i == @size
                j = 0u
                for j < sep.size
                    ptr[pos] = sep[j]
                    j, pos += 1u, 1u
                end
            end
        end

        ptr[pos] = '\0'
        ret new string{ptr, s-1u} # Omit '\0' from size
    end

    func join
        ret @join("")
    end
end

